package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorEx;
import com.qualcomm.robotcore.hardware.Servo;
import com.qualcomm.robotcore.hardware.ColorSensor;

@Autonomous(name = "Pathfinding & Block Placement", group = "Linear Opmode")
public class PathfindingBlockPlacement extends LinearOpMode {

    // Hardware components
    private DcMotor leftDrive;
    private DcMotor rightDrive;
    private DcMotorEx armMotor;
    private Servo wrist;
    private DcMotor intake;
    private ColorSensor colorSensor;

    // Field dimensions and obstacle location
    private static final double FIELD_SIZE = 144.0; // 144 inches (12x12 ft field)
    private static final double OBSTACLE_WIDTH = 44.5; // in inches
    private static final double OBSTACLE_HEIGHT = 26.5; // in inches

    @Override
    public void runOpMode() {
        // Initialize hardware
        leftDrive = hardwareMap.get(DcMotor.class, "leftMotor");
        rightDrive = hardwareMap.get(DcMotor.class, "rightMotor");
        armMotor = hardwareMap.get(DcMotorEx.class, "armMotor");
        wrist = hardwareMap.get(Servo.class, "wrist");
        intake = hardwareMap.get(DcMotor.class, "intake");
        colorSensor = hardwareMap.get(ColorSensor.class, "colorSensor");

        // Set motor directions
        leftDrive.setDirection(DcMotor.Direction.FORWARD);
        rightDrive.setDirection(DcMotor.Direction.REVERSE);
        armMotor.setDirection(DcMotor.Direction.FORWARD);

        // Indicate initialization complete
        telemetry.addLine("Initialization Complete. Waiting for Start...");
        telemetry.update();

        // Wait for the game to start
        waitForStart();

        if (opModeIsActive()) {
            // Step 1: Move forward to detect blocks
            moveForward(0.5, 1500);

            // Step 2: Detect the color of the block
            if (isRedBlock()) {
                telemetry.addLine("Red block detected!");
                moveToBasket(-72, -72);
            } else if (isBlueBlock()) {
                telemetry.addLine("Blue block detected!");
                moveToBasket(72, 72);
            } else if (isYellowBlock()) {
                telemetry.addLine("Yellow block detected!");
                moveToBasket(-72, -72); // Assuming yellow shares red's basket
            } else {
                telemetry.addLine("No valid block detected. Stopping...");
                stopAllMotors();
                return;
            }

            // Step 3: Pick up the block
            pickUpBlock();

            // Step 4: Drop block in the basket
            dropBlockInBasket();

            // Step 5: Reset robot position
            resetArmPosition();
            moveBackward(0.5, 1000);

            telemetry.addLine("Task Complete.");
            telemetry.update();
        }
    }

    // Helper functions

    private void moveForward(double power, long duration) {
        leftDrive.setPower(power);
        rightDrive.setPower(power);
        sleep(duration);
        stopAllMotors();
    }

    private void moveBackward(double power, long duration) {
        leftDrive.setPower(-power);
        rightDrive.setPower(-power);
        sleep(duration);
        stopAllMotors();
    }

    private void stopAllMotors() {
        leftDrive.setPower(0);
        rightDrive.setPower(0);
        armMotor.setPower(0);
        intake.setPower(0);
    }

    private void moveToBasket(int basketX, int basketY) {
        telemetry.addLine("Navigating to Basket...");
        telemetry.update();

        // Navigate around the central obstacle
        if (basketY > OBSTACLE_HEIGHT / 2) {
            // If basket is beyond the obstacle, go around the top
            moveForward(0.5, 1000); // Adjust timing
            turnLeft(90);
            moveForward(0.5, 1000); // Adjust timing
        } else {
            // If basket is below the obstacle, go around the bottom
            moveForward(0.5, 1000); // Adjust timing
            turnRight(90);
            moveForward(0.5, 1000); // Adjust timing
        }

        telemetry.addLine("Reached Basket Area.");
        telemetry.update();
    }

    private void pickUpBlock() {
        intake.setPower(1.0); // Start the intake to pick up the block
        while (colorSensor.red() > 0 || colorSensor.blue() > 0 || colorSensor.green() > 0) {
            // Wait until the block is no longer sensed (indicating it's picked up)
            telemetry.addLine("Picking up block...");
            telemetry.update();
        }
        intake.setPower(0); // Stop the intake
        liftArm(); // Lift the block for transport
    }

    private void liftArm() {
        armMotor.setTargetPosition(500); // Adjust based on arm's vertical position for baskets
        armMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        armMotor.setVelocity(2100);
        while (armMotor.isBusy()) {
            // Wait for the arm to reach the position
        }
    }

    private void dropBlockInBasket() {
        wrist.setPosition(0.0); // Adjust wrist to drop position
        sleep(500);
    }

    private void resetArmPosition() {
        armMotor.setTargetPosition(0); // Return the arm to starting position
        armMotor.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        armMotor.setVelocity(2100);
        while (armMotor.isBusy()) {
            // Wait for the arm to reset
        }
    }

    private boolean isRedBlock() {
        return colorSensor.red() > colorSensor.blue() && colorSensor.red() > colorSensor.green();
    }

    private boolean isBlueBlock() {
        return colorSensor.blue() > colorSensor.red() && colorSensor.blue() > colorSensor.green();
    }

    private boolean isYellowBlock() {
        return colorSensor.green() > colorSensor.red() && colorSensor.green() > colorSensor.blue();
    }

    private void turnLeft(int degrees) {
        // Logic for turning left
        telemetry.addData("Turning Left", "%d degrees", degrees);
        telemetry.update();
        sleep(500); // Placeholder
    }

    private void turnRight(int degrees) {
        // Logic for turning right
        telemetry.addData("Turning Right", "%d degrees", degrees);
        telemetry.update();
        sleep(500); // Placeholder
    }
}